<!-- è°·æ­Œåœ°å›¾é€‰æ‹©ï¼Œä½¿ç”¨web-viewå†…åµŒæ˜¾ç¤º -->
<!DOCTYPE html>
<!-- uni çš„ SDK -->
<script type="text/javascript" src="./uni.webview.1.5.6.js"></script>
<html>
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<title>è°·æ­Œåœ°å›¾æœç´¢</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body,
			html {
				height: 100%;
				font-family: Arial, sans-serif;
			}

			.container {
				height: 100%;
				display: flex;
				flex-direction: column;
			}

			.header {
				background: #fff;
				padding: 10px;
				box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
				z-index: 100;
				padding-top: 50px;
				display: none;
			}

			.search-container {
				display: flex;
				align-items: center;
				margin-bottom: 10px;
			}
			.search-back {
				font-size: 20px;
				padding-right: 10px;
			}
			.search-input {
				flex: 1;
				padding: 10px;
				border: 1px solid #ddd;
				border-radius: 4px 0 0 4px;
				font-size: 14px;
			}

			.search-btn {
				padding: 10px 15px;
				background: #4285f4;
				color: white;
				border: none;
				border-radius: 0 4px 4px 0;
				cursor: pointer;
			}

			.tabs {
				display: flex;
				border-bottom: 1px solid #eee;
			}

			.tab {
				flex: 1;
				text-align: center;
				padding: 10px;
				cursor: pointer;
				background: #f5f5f5;
			}

			.tab.active {
				background: #4285f4;
				color: white;
			}

			.map-container {
				flex: 1;
				position: relative;
			}

			#map {
				width: 100%;
				height: 100%;
			}

			.results-panel {
				/* position: absolute;
				top: 10px;
				left: 1vw;
				width: 98vw; */
				height: 40vh;
				background: white;
				border-radius: 4px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
				z-index: 99;
				overflow-y: auto;
				display: none;
			}

			.result-item {
				padding: 15px;
				border-bottom: 1px solid #eee;
				cursor: pointer;
			}

			.result-item:hover {
				background: #f5f5f5;
			}

			.result-name {
				font-weight: bold;
				margin-bottom: 5px;
			}

			.result-address {
				font-size: 12px;
				color: #666;
				margin-bottom: 5px;
			}

			.result-rating {
				font-size: 12px;
				color: #f57c00;
			}

			.close-btn {
				padding: 5px;
				position: absolute;
				top: 5px;
				right: 5px;
				background: none;
				border: none;
				font-size: 18px;
				cursor: pointer;
			}

			.current-location-btn {
				position: absolute;
				bottom: 25px;
				right: 10px;
				background: white;
				border: 1px solid #ccc;
				border-radius: 4px;
				padding: 10px;
				cursor: pointer;
				box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
				z-index: 99;
			}

			.loading {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				background: rgba(0, 0, 0, 0.7);
				color: white;
				padding: 10px 20px;
				border-radius: 4px;
				z-index: 100;
				display: none;
			}
			
			.route-info {
				position: relative;
			}
			.route-summary {
				/* position: absolute;
				left: 0;
				top: 0; */
				font-size: 14px;
				color: #000;
				padding: 2px 10px;
				border-radius: 20px;
				background: #fff;
				font-weight: 400;
			}
			
			/* è‡ªå®šä¹‰Marker labelæ ·å¼ */
			.custom-marker-label {
			  background-color: #fff;
			  border-radius: 20px;
			  padding: 4px 8px;
			  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
				margin: -10px 0 0 80px;
			}
			
		</style>
	</head>
	<body>
		<div class="container">
			<div class="header" id="header">
				<div class="search-container">
					<div id="searchBack" class="search-back"><</div>
					<input type="text" id="searchInput" class="search-input" placeholder="æœç´¢åœ°ç‚¹...">
					<button id="searchBtn" class="search-btn">æœç´¢</button>
				</div>
				<!-- <div class="tabs">
					<div class="tab active" data-type="nearby">é™„è¿‘æœç´¢</div>
					<div class="tab" data-type="text">æ–‡æœ¬æœç´¢</div>
				</div> -->
			</div>

			<div class="map-container">
				<div id="map"></div>
				<div class="loading" id="loading">æœç´¢ä¸­...</div>
				<button class="current-location-btn" id="currentLocationBtn">ğŸ“</button>

			</div>
			<div class="results-panel" id="resultsPanel">
				<button class="close-btn" id="closeResults">Ã—</button>
				<div id="resultsList"></div>
			</div>
		</div>

		<script>
			let map, placesManager, directionsManager, directionsRenderer, currentLocation, markers = [], mapTypeLibraries;
			// ç»ˆç‚¹ç»çº¬åº¦
			let destinationObj = {}
			// åˆå§‹åŒ–åœ°å›¾
			function initMap() {
				map = new google.maps.Map(document.getElementById('map'), {
					center: {
						lat: 39.9042,
						lng: 116.4074
					},
					zoom: 15,
					// è¡—æ™¯å°äººæ§ä»¶
					streetViewControl: false,
					// åœ°å›¾ç±»å‹æ§ä»¶
					mapTypeControl: false,
					// å…¨å±æ¨¡å¼æ‰“å¼€åœ°å›¾çš„æ§ä»¶
					fullscreenControl: false,
				});
				placesManager = new google.maps.places.PlacesService(map);
				sendMessageToApp({
					action: 'loading'
				})
				// è·å–å½“å‰ä½ç½®
				getCurrentLocation();
				// ç»‘å®šäº‹ä»¶
				bindEvents();
				// æœç´¢
				if (mapTypeLibraries === 'places') {
					document.getElementById('header').style.display = 'block';
				}
				
				
				// directionsManager = new google.maps.DirectionsService();
				// directionsRenderer = new google.maps.DirectionsRenderer({
				// 	map: map,
				// 	suppressMarkers: false,
				// 	polylineOptions: {
				// 		strokeColor: '#0066CC',
				// 		strokeWeight: 5
				// 	}
				// })
				if (mapTypeLibraries === 'directions') {
					// è·¯ç¨‹è§„åˆ’
					// directionsManager = new google.maps.directions.DirectionsService(map);
					// directionsRenderer = new google.maps.directions.DirectionsRenderer({
					// 	map: map,
					// 	suppressMarkers: false,
					// 	polylineOptions: {
					// 		strokeColor: '#0066CC',
					// 		strokeWeight: 5
					// 	}
					// })
					// setTimeout(function() {
					// 	planRoute()
					// },2000)
				}
				
			}

			// ç»‘å®šäº‹ä»¶
			function bindEvents() {
				document.getElementById('searchBack').addEventListener('click', onSearchBack);
				document.getElementById('searchBtn').addEventListener('click', performSearch);
				document.getElementById('searchInput').addEventListener('keypress', function(e) {
					if (e.key === 'Enter') {
						performSearch();
					}
				});

				document.getElementById('currentLocationBtn').addEventListener('click', getCurrentLocation);
				document.getElementById('closeResults').addEventListener('click', function() {
					document.getElementById('resultsPanel').style.display = 'none';
				});

				// æ ‡ç­¾åˆ‡æ¢
				document.querySelectorAll('.tab').forEach(tab => {
					tab.addEventListener('click', function() {
						document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
						this.classList.add('active');
					});
				});
			}

			// è·å–å½“å‰ä½ç½®
			function getCurrentLocation() {
				showLoading(true);

				if (navigator.geolocation) {
					navigator.geolocation.getCurrentPosition(
						position => {
							currentLocation = {
								lat: position.coords.latitude,
								lng: position.coords.longitude
							};
							let label = {}
							if (mapTypeLibraries === 'directions') {
								let contLocation = calculateCenterPoint(currentLocation.lat, currentLocation.lng,destinationObj.lat,destinationObj.lng)
								map.setCenter(contLocation);
								label = {
									text: 'èµ·ç‚¹',
									color: '#000',
									fontSize: '14px',
									className: 'custom-marker-label'
								}
								// ç»ˆç‚¹
								const destination = new google.maps.Marker({
									position: destinationObj,
									map: map,
									title: 'ç»ˆç‚¹',
									icon: '../imgs/group-from.png',
									label: {
										text: 'ç»ˆç‚¹',
										color: '#000',
										fontSize: '14px',
										className: 'custom-marker-label'
									}
								});
								
								// ç›´çº¿è·¯çº¿
								drawRouteLine(currentLocation, destinationObj)
							} else {
								map.setCenter(currentLocation);
							}
							
							// æ·»åŠ å½“å‰ä½ç½®æ ‡è®°
							const marker = new google.maps.Marker({
								position: currentLocation,
								map: map,
								title: 'å½“å‰ä½ç½®',
								icon: '../imgs/group-go.png',
								label,
							});

							showLoading(false);
							
							if (mapTypeLibraries === 'places') {
								// å¦‚æœè¾“å…¥æ¡†ä¸ºç©ºï¼Œè‡ªåŠ¨æœç´¢é™„è¿‘çš„åœ°ç‚¹
								if (!document.getElementById('searchInput').value.trim()) {
									searchNearbyPlaces('');
								}
							}
							
						},
						error => {
							console.error('è·å–ä½ç½®å¤±è´¥:', error);
							showLoading(false);
						}
					);
				} else {
					showLoading(false);
				}
			}
			
			// è¿”å›ä¸Šä¸€é¡µ
			function onSearchBack() {
				uni.navigateBack()
			}

			// æ‰§è¡Œæœç´¢
			function performSearch() {
				const query = document.getElementById('searchInput').value.trim();
				// const searchType = document.querySelector('.tab.active').dataset.type;

				if (!query) {
					alert('è¯·è¾“å…¥æœç´¢å…³é”®è¯');
					return;
				}

				// if (searchType === 'nearby') {
				// 	searchNearbyPlaces(query);
				// } else {
				// 	searchTextPlaces(query);
				// }
				searchTextPlaces(query);
			}

			// é™„è¿‘æœç´¢
			function searchNearbyPlaces(keyword) {
				if (!currentLocation) {
					alert('è¯·å…ˆè·å–å½“å‰ä½ç½®');
					return;
				}

				showLoading(true);

				const request = {
					location: currentLocation,
					radius: 1000, // 1å…¬é‡ŒèŒƒå›´
					keyword: keyword,
					types: ['restaurant'],
				};

				placesManager.nearbySearch(request, (results, status) => {
					showLoading(false);

					if (status === google.maps.places.PlacesServiceStatus.OK) {
						displayResults(results);
						displayPlacesOnMap(results);
					} else {
						alert('æœç´¢å¤±è´¥: ' + status);
					}
				});
			}

			// æ–‡æœ¬æœç´¢
			function searchTextPlaces(query) {
				showLoading(true);

				const request = {
					query: query,
					...(currentLocation ? {
						location: currentLocation,
						radius: 5000
					} : {})
				};

				placesManager.textSearch(request, (results, status) => {
					showLoading(false);

					if (status === google.maps.places.PlacesServiceStatus.OK) {
						displayResults(results, query);
						displayPlacesOnMap(results);
					} else {
						alert('æœç´¢å¤±è´¥: ' + status);
					}
				});
			}

			// æ˜¾ç¤ºæœç´¢ç»“æœ
			function displayResults(results, query) {
				const resultsList = document.getElementById('resultsList');
				resultsList.innerHTML = '';
				
				// ä¸­å¿ƒç‚¹
				if (query) {
					map.setCenter(results[0].geometry.location);
					map.setZoom(17);
				}
				
				
				let nearbyList = results.map(item => {
					
					const distance = calculateHaversineDistance(
							currentLocation.lat,
							currentLocation.lng,
							item.geometry.location.lat(),
							item.geometry.location.lng()
					);
					return {
						...item,
						distance,
						address: item.vicinity,
						lat: item.geometry.location.lat(),
						lng: item.geometry.location.lng(),
					};
				}).sort((a, b) => a.distance - b.distance)
				nearbyList = nearbyList.map(item => {
					return {
						...item,
						distance: item.distance > 1 ? `${item.distance.toFixed(2)}km` : item.distance ? `${parseInt(item.distance*1000)}m` : '',
					}
				})

				nearbyList.forEach((place, index) => {
					const item = document.createElement('div');
					item.className = 'result-item';
					item.innerHTML = `
                    <div class="result-name">${place.name}</div>
                    <div class="result-address">${place.vicinity || place.formatted_address || ''}</div>
                    <div class="result-rating">
                        è·ç¦»: ${place.distance} 
                        
                    </div>
                `;

					item.addEventListener('click', () => {
						console.log('è¯¦æƒ…ä¿¡æ¯', place)
						// ç‚¹å‡»ç»“æœé¡¹ï¼Œåœ¨åœ°å›¾ä¸Šå±…ä¸­æ˜¾ç¤º
						if (place.geometry && place.geometry.location) {
							map.setCenter(place.geometry.location);
							map.setZoom(17);
							sendMessageToApp({
								action: 'info',
								info: place
							})
						}
					});

					resultsList.appendChild(item);
				});

				document.getElementById('resultsPanel').style.display = 'block';
			}

			// åœ¨åœ°å›¾ä¸Šæ˜¾ç¤ºåœ°ç‚¹
			function displayPlacesOnMap(places) {
				// æ¸…é™¤ä¹‹å‰æ ‡è®°
				clearMarkers();

				places.forEach(place => {
					if (!place.geometry || !place.geometry.location) return;

					const marker = new google.maps.Marker({
						position: place.geometry.location,
						map: map,
						title: place.name,
						icon: '../imgs/group-from.png',
					});

					// æ·»åŠ ä¿¡æ¯çª—å£
					const infoWindow = new google.maps.InfoWindow({
						headerContent: `${place.name}`,
						content: `<div>
												<p style="margin: 0 0 5px 0; font-size: 12px;">${place.vicinity || place.formatted_address || ''}</p>
												<p style="margin: 0; font-size: 12px;">è¯„åˆ†: ${place.rating || 'æš‚æ— '} (${place.user_ratings_total || 0}æ¡è¯„è®º)</p>
										</div>`
					});

					marker.addListener('click', () => {
						infoWindow.open(map, marker);
					});

					markers.push(marker);
				});
			}

			// æ¸…é™¤æ ‡è®°
			function clearMarkers() {
				markers.forEach(marker => marker.setMap(null));
				markers = [];
			}

			// æ˜¾ç¤º/éšè—åŠ è½½çŠ¶æ€
			function showLoading(show) {
				document.getElementById('loading').style.display = show ? 'block' : 'none';
			}

			// ä»APPæ¥æ”¶APIå¯†é’¥
			function setApiKey(apiKey, language, region, libraries, destination) {
				mapTypeLibraries = libraries
				destinationObj = destination || {}
				if (apiKey) {
					window.GOOGLE_MAPS_API_KEY = apiKey;
					// é‡æ–°åŠ è½½åœ°å›¾API
					const script = document.createElement('script');
					script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places&callback=initMap&language=${language}&region=${region}`;
					script.async = true;
					script.defer = true;
					document.head.appendChild(script);
				}
			}

			// æ¥æ”¶æ¥è‡ªAPPçš„æ¶ˆæ¯
			window.addEventListener('message', function(event) {
				console.log('æ¥æ”¶æ¥è‡ªAPPçš„æ¶ˆæ¯')
				const data = event.data;
				if (data.action === 'setApiKey') {
					setApiKey(data.apiKey);
				} else if (data.action === 'search') {
					document.getElementById('searchInput').value = data.query || '';
					performSearch();
				} else if (data.action === 'setLocation') {
					currentLocation = {
						lat: data.lat,
						lng: data.lng
					};
					map.setCenter(currentLocation);
				}
			});

			// htmlå‘é€ç»™web-view
			function sendMessageToApp(data) {
				try {
					// #ifdef H5
					if (window.MapIsH5) {
						window.documentPictureInPicture.setGoogleInfo(data)
						return true;
					}
					
					// #endif
					// æ–¹æ³•1: ä½¿ç”¨uni.postMessage (æ¨è)
					if (typeof uni !== 'undefined') {
						uni.postMessage({
							data: data
						});
						
						return true;
					}

					// æ–¹æ³•2: ä½¿ç”¨postMessage (å…¼å®¹æ—§ç‰ˆæœ¬)
					if (window.parent && window.parent !== window) {
						window.parent.postMessage(data, '*');
						return true;
					}

					// æ–¹æ³•3: ä½¿ç”¨Androidç‰¹å®šæ¥å£
					if (window.Android && typeof window.Android.postMessage === 'function') {
						window.Android.postMessage(JSON.stringify(data));
						return true;
					}

					return false;
				} catch (error) {
					return false;
				}
			}
			
			
			
			// è§„åˆ’è·¯çº¿
			function planRoute() {
				// if (!this.origin || !this.destination) {
				// 	uni.showToast({
				// 		title: 'è¯·è¾“å…¥èµ·ç‚¹å’Œç»ˆç‚¹',
				// 		icon: 'none'
				// 	})
				// 	return
				// }
				
				const request = {
					origin: 'å…«æœˆèŠ±',
					destination: 'ç æ±Ÿé…’å®¶',
					// waypoints: [],
					travelMode: google.maps.TravelMode.DRIVING,
					optimizeWaypoints: true
				}
				
				directionsService.route(request, (result, status) => {
					if (status === 'OK') {
						directionsRenderer.setDirections(result)
						displayRouteInfo(result)
					} else {
						// uni.showToast({
						// 	title: 'è·¯çº¿è§„åˆ’å¤±è´¥: ' + status,
						// 	icon: 'none'
						// })
						console.log('å¤±è´¥')
					}
				})
			}
			
			// æ˜¾ç¤ºè·¯çº¿ä¿¡æ¯
			function displayRouteInfo(result) {
				const route = result.routes[0]
				const summaryPanel = document.createElement('div')
				summaryPanel.className = 'route-info'
				
				// è®¡ç®—æ€»è·ç¦»å’Œæ—¶é—´
				let totalDistance = 0
				let totalDuration = 0
				
				for (let i = 0; i < route.legs.length; i++) {
					totalDistance += route.legs[i].distance.value
					totalDuration += route.legs[i].duration.value
				}
				
				const distanceInKm = (totalDistance / 1000).toFixed(2)
				const durationInMin = Math.round(totalDuration / 60)
				
				summaryPanel.innerHTML = `
					<div class="route-summary">
						<h3>è¡Œç¨‹ä¿¡æ¯</h3>
						<p>æ€»è·ç¦»: ${distanceInKm} å…¬é‡Œ</p>
						<p>é¢„è®¡æ—¶é—´: ${durationInMin} åˆ†é’Ÿ</p>
					</div>
				`
				
				// å°†ä¿¡æ¯é¢æ¿æ·»åŠ åˆ°åœ°å›¾ä¸Š
				map.controls[google.maps.ControlPosition.TOP_CENTER].push(summaryPanel)
			}
			
			// ç»˜åˆ¶ä¸¤ç‚¹ä¹‹é—´çš„è·¯çº¿çº¿
			function drawRouteLine(start, end) {
				const routePath = new google.maps.Polyline({
					path: [start, end],
					geodesic: true,
					strokeColor: '#FF0000',
					strokeOpacity: 1.0,
					strokeWeight: 2
				});
				
				routePath.setMap(map);
			}
			
			// è®¡ç®—è·ç¦»
			function calculateHaversineDistance(lat1, lon1, lat2, lon2) {
					const R = 6371; // åœ°çƒåŠå¾„ï¼Œå•ä½ï¼šåƒç±³
					const dLat = (lat2 - lat1) * (Math.PI / 180);
					const dLon = (lon2 - lon1) * (Math.PI / 180);
					const a =
							Math.sin(dLat / 2) * Math.sin(dLat / 2) +
							Math.cos(lat1 * (Math.PI / 180)) *
							Math.cos(lat2 * (Math.PI / 180)) *
							Math.sin(dLon / 2) * Math.sin(dLon / 2);
					const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
					return R * c;
			}
			
			// è®¡ç®—ä¸¤ä¸ªç»çº¬åº¦åæ ‡ä¹‹é—´çš„ä¸­å¿ƒç‚¹
			function calculateCenterPoint(lat1, lng1, lat2, lng2) {
			  // å°†è§’åº¦è½¬æ¢ä¸ºå¼§åº¦
			  const toRadians = (degrees) => degrees * (Math.PI / 180);
			  // å°†å¼§åº¦è½¬æ¢ä¸ºè§’åº¦
			  const toDegrees = (radians) => radians * (180 / Math.PI);
			  
			  const radLat1 = toRadians(lat1);
			  const radLat2 = toRadians(lat2);
			  const deltaLng = toRadians(lng2 - lng1);
			  
			  const bx = Math.cos(radLat2) * Math.cos(deltaLng);
			  const by = Math.cos(radLat2) * Math.sin(deltaLng);
			  
			  const centerLat = Math.atan2(
			    Math.sin(radLat1) + Math.sin(radLat2),
			    Math.sqrt((Math.cos(radLat1) + bx) * (Math.cos(radLat1) + bx) + by * by)
			  );
			  
			  const centerLng = toRadians(lng1) + Math.atan2(by, Math.cos(radLat1) + bx);
			  
			  return {
			    lat: toDegrees(centerLat),
			    lng: toDegrees(centerLng)
			  };
			}
			
		</script>
	</body>
</html>